"use strict";
/*!
This file is part of CycloneDX generator for NPM projects.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

SPDX-License-Identifier: Apache-2.0
Copyright (c) OWASP Foundation. All Rights Reserved.
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TreeBuilder = exports.BomBuilder = void 0;
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
const cyclonedx_library_1 = require("@cyclonedx/cyclonedx-library");
const normalize_package_data_1 = __importDefault(require("normalize-package-data"));
const _helpers_1 = require("./_helpers");
class BomBuilder {
    npmRunner;
    componentBuilder;
    leGatherer;
    treeBuilder;
    purlFactory;
    ignoreNpmErrors;
    metaComponentType;
    packageLockOnly;
    omitDependencyTypes;
    reproducible;
    flattenComponents;
    shortPURLs;
    gatherLicenseTexts;
    workspace;
    includeWorkspaceRoot;
    workspaces;
    console;
    constructor(npmRunner, componentBuilder, treeBuilder, purlFactory, leFetcher, options, console_) {
        this.npmRunner = npmRunner;
        this.componentBuilder = componentBuilder;
        this.treeBuilder = treeBuilder;
        this.purlFactory = purlFactory;
        this.leGatherer = leFetcher;
        this.ignoreNpmErrors = options.ignoreNpmErrors ?? false;
        this.metaComponentType = options.metaComponentType ?? cyclonedx_library_1.Enums.ComponentType.Library;
        this.packageLockOnly = options.packageLockOnly ?? false;
        this.omitDependencyTypes = new Set(options.omitDependencyTypes ?? []);
        this.reproducible = options.reproducible ?? false;
        this.flattenComponents = options.flattenComponents ?? false;
        this.shortPURLs = options.shortPURLs ?? false;
        this.gatherLicenseTexts = options.gatherLicenseTexts ?? false;
        this.workspace = options.workspace ?? [];
        this.includeWorkspaceRoot = options.includeWorkspaceRoot;
        this.workspaces = options.workspaces;
        this.console = console_;
    }
    buildFromProjectDir(projectDir, process_) {
        return this.buildFromNpmLs(this.fetchNpmLs(projectDir, process_), this.npmRunner.getVersion({ env: process_.env }));
    }
    fetchNpmLs(projectDir, process_) {
        const args = [
            'ls',
            '--json',
            '--long',
            '--all'
        ];
        if (this.packageLockOnly) {
            args.push('--package-lock-only');
        }
        for (const odt of this.omitDependencyTypes) {
            args.push(`--omit=${odt}`);
        }
        for (const workspace of this.workspace) {
            args.push(`--workspace=${workspace}`);
        }
        if (this.includeWorkspaceRoot !== undefined) {
            args.push(`--include-workspace-root=${this.includeWorkspaceRoot}`);
        }
        if (this.workspaces !== undefined) {
            args.push(`--workspaces=${this.workspaces}`);
        }
        this.console.info('INFO  | gathering dependency tree ...');
        this.console.debug('DEBUG | npm-ls: run npm with %j in %j', args, projectDir);
        let npmLsReturns;
        try {
            npmLsReturns = this.npmRunner.run(args, {
                cwd: projectDir,
                env: process_.env,
                stdio: ['ignore', 'pipe', 'pipe'],
                encoding: 'buffer',
                maxBuffer: Number.MAX_SAFE_INTEGER
            });
        }
        catch (runError) {
            this.console.group('WARN  | npm-ls: MESSAGE');
            this.console.warn('%s', runError.message);
            this.console.groupEnd();
            this.console.group('ERROR | npm-ls: STDERR');
            this.console.error('%s', runError.stderr);
            this.console.groupEnd();
            if (!this.ignoreNpmErrors) {
                throw new Error(`npm-ls exited with errors: ${runError.status ?? 'noStatus'} ${runError.signal ?? 'noSignal'}`, { cause: runError });
            }
            this.console.debug('DEBUG | npm-ls exited with errors that are to be ignored.');
            npmLsReturns = runError.stdout ?? Buffer.alloc(0);
        }
        try {
            return JSON.parse(npmLsReturns.toString());
        }
        catch (jsonParseError) {
            throw new Error('failed to parse npm-ls response', { cause: jsonParseError });
        }
    }
    buildFromNpmLs(data, npmVersion) {
        this.console.info('INFO  | building BOM ...');
        const dataPath = data.path;
        if (!(0, _helpers_1.isString)(dataPath) || dataPath.length === 0) {
            throw new Error(`unexpected path ${JSON.stringify(dataPath)}`);
        }
        const rootComponent = this.makeComponent(data, this.metaComponentType) ||
            new DummyComponent(this.metaComponentType, 'RootComponent');
        const allComponents = new Map([[dataPath, rootComponent]]);
        this.gatherDependencies(allComponents, data, rootComponent.dependencies);
        this.finalizePathProperties(dataPath, allComponents.values());
        const bom = new cyclonedx_library_1.Models.Bom();
        bom.metadata.component = rootComponent;
        bom.metadata.tools.components.add(new cyclonedx_library_1.Models.Component(cyclonedx_library_1.Enums.ComponentType.Application, 'npm', {
            version: npmVersion
        }));
        for (const toolC of this.makeToolCs()) {
            bom.metadata.tools.components.add(toolC);
        }
        if (!this.reproducible) {
            bom.serialNumber = cyclonedx_library_1.Utils.BomUtility.randomSerialNumber();
            bom.metadata.timestamp = new Date();
        }
        bom.components = this.nestComponents(new Map(Array.from(allComponents.entries()).filter(([, c]) => c !== rootComponent)), this.treeBuilder.fromPaths(new Set(allComponents.keys()), dataPath.startsWith('/') ? '/' : '\\'));
        bom.components.forEach(c => { this.adjustNestedBomRefs(c, ''); });
        rootComponent.components.clear();
        if (this.flattenComponents) {
            for (const component of allComponents.values()) {
                component.components.clear();
                if (component !== rootComponent) {
                    bom.components.add(component);
                }
            }
        }
        return bom;
    }
    adjustNestedBomRefs(component, pref) {
        if (component.bomRef.value === undefined) {
            return;
        }
        component.bomRef.value = pref + component.bomRef.value;
        const fill = component.bomRef.value + '|';
        component.components.forEach(c => { this.adjustNestedBomRefs(c, fill); });
    }
    nestComponents(allComponents, tree) {
        const children = new cyclonedx_library_1.Models.ComponentRepository();
        for (const [p, pTree] of tree) {
            const component = allComponents.get(p);
            const components = this.nestComponents(allComponents, pTree);
            if (component === undefined) {
                components.forEach(c => children.add(c));
            }
            else {
                component.components = components;
                children.add(component);
            }
        }
        return children;
    }
    gatherDependencies(allComponents, data, directDepRefs) {
        for (const [depName, depData] of Object.entries(data.dependencies ?? {})) {
            if (depData === null || typeof depData !== 'object') {
                this.console.debug('DEBUG | skip malformed component %j in %j', depName, depData);
                continue;
            }
            const depPath = depData.path;
            if (!(0, _helpers_1.isString)(depPath) || depPath.length === 0) {
                this.console.debug('DEBUG | skip missing component %j in %j', depName, depPath);
                continue;
            }
            let dep = allComponents.get(depPath);
            if (dep === undefined) {
                const _dep = this.makeComponent(depData);
                if (_dep === false) {
                    this.console.debug('DEBUG | skip impossible component %j in %j', depName, depPath);
                    continue;
                }
                dep = _dep ??
                    new DummyComponent(cyclonedx_library_1.Enums.ComponentType.Library, `InterferedDependency.${depName}`);
                if (dep instanceof DummyComponent) {
                    this.console.warn('WARN  | InterferedDependency %j in %j', depName, depPath);
                }
                else {
                    this.console.debug('DEBUG | built component %j in %j: %j', depName, depPath, dep);
                }
                this.console.info('INFO  | add component for %j in %j', depName, depPath);
                allComponents.set(depPath, dep);
            }
            directDepRefs.add(dep.bomRef);
            this.gatherDependencies(allComponents, depData, dep.dependencies);
        }
    }
    enhancedPackageData(data) {
        if (!node_path_1.default.isAbsolute(data.path)) {
            this.console.debug('DEBUG | skip loading package manifest in %j', data.path);
            return data;
        }
        const packageJsonPath = node_path_1.default.join(data.path, 'package.json');
        try {
            return Object.assign((0, _helpers_1.loadJsonFile)(packageJsonPath) ?? {}, data);
        }
        catch (err) {
            this.console.debug('DEBUG | failed loading package manifest %j: %s', packageJsonPath, err);
            return data;
        }
    }
    resolvedRE_ignore = /^(?:ignore|file):/i;
    makeComponent(data, type) {
        const isOptional = data.optional === true;
        if (isOptional && this.omitDependencyTypes.has('optional')) {
            this.console.debug('DEBUG | omit optional component: %j %j', data.name, data._id);
            return false;
        }
        const isDev = data.dev === true;
        if (isDev && this.omitDependencyTypes.has('dev')) {
            this.console.debug('DEBUG | omit dev component: %j %j', data.name, data._id);
            return false;
        }
        const isDevOptional = data.devOptional === true;
        if (isDevOptional && this.omitDependencyTypes.has('dev') && this.omitDependencyTypes.has('optional')) {
            this.console.debug('DEBUG | omit devOptional component: %j %j', data.name, data._id);
            return false;
        }
        let _dataC = (0, _helpers_1.structuredClonePolyfill)(data);
        if (!this.packageLockOnly) {
            _dataC = this.enhancedPackageData(_dataC);
        }
        (0, normalize_package_data_1.default)(_dataC);
        if ((0, _helpers_1.isString)(data.version)) {
            _dataC.version = data.version.trim();
        }
        const component = this.componentBuilder.makeComponent(_dataC, type);
        if (component === undefined) {
            this.console.debug('DEBUG | skip broken component: %j %j', data.name, data._id);
            return undefined;
        }
        component.licenses.forEach(l => {
            l.acknowledgement = cyclonedx_library_1.Enums.LicenseAcknowledgement.Declared;
        });
        if (this.gatherLicenseTexts) {
            if (this.packageLockOnly) {
                this.console.warn('WARN  | Adding license text is ignored (package-lock-only is configured!) for %j', data.name);
            }
            else {
                component.evidence = new cyclonedx_library_1.Models.ComponentEvidence();
                for (const license of this.fetchLicenseEvidence(data.path)) {
                    component.evidence ??= new cyclonedx_library_1.Models.ComponentEvidence();
                    component.evidence.licenses.add(license);
                }
            }
        }
        if (isOptional || isDevOptional) {
            component.scope = cyclonedx_library_1.Enums.ComponentScope.Optional;
        }
        if ((0, _helpers_1.isString)(data.path)) {
            component.properties.add(new cyclonedx_library_1.Models.Property("cdx:npm:package:path", data.path));
        }
        if (isDev || isDevOptional) {
            component.properties.add(new cyclonedx_library_1.Models.Property("cdx:npm:package:development", "true"));
        }
        if (data.extraneous === true) {
            component.properties.add(new cyclonedx_library_1.Models.Property("cdx:npm:package:extraneous", "true"));
        }
        if (data.private === true || _dataC.private === true) {
            component.properties.add(new cyclonedx_library_1.Models.Property("cdx:npm:package:private", "true"));
        }
        if (data.inBundle === true) {
            component.properties.add(new cyclonedx_library_1.Models.Property("cdx:npm:package:bundled", "true"));
        }
        const resolved = data.resolved;
        if ((0, _helpers_1.isString)(resolved) && !this.resolvedRE_ignore.test(resolved)) {
            const hashes = new cyclonedx_library_1.Models.HashDictionary();
            const integrity = data.integrity;
            if ((0, _helpers_1.isString)(integrity)) {
                try {
                    hashes.set(...cyclonedx_library_1.Utils.NpmjsUtility.parsePackageIntegrity(integrity));
                }
                catch { }
            }
            component.externalReferences.add(new cyclonedx_library_1.Models.ExternalReference((0, _helpers_1.tryRemoveSecretsFromUrl)(resolved), cyclonedx_library_1.Enums.ExternalReferenceType.Distribution, {
                hashes,
                comment: 'as detected from npm-ls property "resolved"' +
                    (hashes.size > 0 ? ' and property "integrity"' : '')
            }));
        }
        component.purl = this.makePurl(component);
        component.bomRef.value = ((0, _helpers_1.isString)(data._id) ? data._id : undefined) ||
            `${component.group || '-'}/${component.name}@${component.version || '-'}`;
        return component;
    }
    makePurl(component) {
        const purl = this.purlFactory.makeFromComponent(component, this.reproducible);
        if (purl === undefined) {
            return undefined;
        }
        if (this.shortPURLs) {
            purl.qualifiers = undefined;
            purl.subpath = undefined;
        }
        return purl;
    }
    finalizePathProperties(rootPath, components) {
        if (!(0, _helpers_1.isString)(rootPath) || rootPath === '') {
            return;
        }
        const [relativePath, dirSepRE] = rootPath.startsWith('/')
            ? [node_path_1.default.posix.relative, /\//g]
            : [node_path_1.default.win32.relative, /\\/g];
        for (const component of components) {
            for (const property of component.properties) {
                if (property.name !== "cdx:npm:package:path") {
                    continue;
                }
                if (property.value === '') {
                    component.properties.delete(property);
                    continue;
                }
                property.value = relativePath(rootPath, property.value).replace(dirSepRE, '/');
            }
        }
    }
    *makeToolCs() {
        const packageJsonPaths = [
            [node_path_1.default.resolve(module.path, '..', 'package.json'), cyclonedx_library_1.Enums.ComponentType.Application]
        ];
        const libs = [
            '@cyclonedx/cyclonedx-library'
        ].map(s => s.split('/', 2));
        const nodeModulePaths = require.resolve.paths('__some_none-native_package__') ?? [];
        libsLoop: for (const lib of libs) {
            for (const nodeModulePath of nodeModulePaths) {
                const packageJsonPath = node_path_1.default.resolve(nodeModulePath, ...lib, 'package.json');
                if ((0, node_fs_1.existsSync)(packageJsonPath)) {
                    packageJsonPaths.push([packageJsonPath, cyclonedx_library_1.Enums.ComponentType.Library]);
                    continue libsLoop;
                }
            }
        }
        for (const [packageJsonPath, cType] of packageJsonPaths) {
            const packageData = (0, _helpers_1.loadJsonFile)(packageJsonPath) ?? {};
            (0, normalize_package_data_1.default)(packageData);
            const toolC = this.componentBuilder.makeComponent(packageData, cType);
            if (toolC !== undefined) {
                yield toolC;
            }
        }
    }
    *fetchLicenseEvidence(dirPath) {
        const files = this.leGatherer.getFileAttachments(dirPath, (error) => {
            this.console.info(`INFO  | ${error.message}`);
            this.console.debug(`DEBUG | ${error.message} -`, error);
        });
        try {
            for (const { file, text } of files) {
                yield new cyclonedx_library_1.Models.NamedLicense(`file: ${file}`, { text });
            }
        }
        catch (e) {
            this.console.warn('WARN  | collecting license evidence in', dirPath, 'failed:', e);
        }
    }
}
exports.BomBuilder = BomBuilder;
class DummyComponent extends cyclonedx_library_1.Models.Component {
    constructor(type, name) {
        super(type, `DummyComponent.${name}`, {
            bomRef: `DummyComponent.${name}`,
            description: `This is a dummy component "${name}" that fills the gap where the actual built failed.`
        });
    }
}
class TreeBuilder {
    fromPaths(paths, dirSeparator) {
        const tree = new Map(Array.from(paths, p => [p + dirSeparator, new Map()]));
        this.nestPT(tree);
        this.renderPR(tree, '');
        return tree;
    }
    renderPR(tree, pref) {
        for (const [p, pTree] of [...tree.entries()]) {
            tree.delete(p);
            const pFull = pref + p;
            this.renderPR(pTree, pFull);
            tree.set(pFull.slice(undefined, -1), pTree);
        }
    }
    nestPT(tree) {
        if (tree.size < 2) {
            return;
        }
        for (const [a, aTree] of tree) {
            for (const [b, bTree] of tree) {
                if (a === b) {
                    continue;
                }
                if (b.startsWith(a)) {
                    aTree.set(b.slice(a.length), bTree);
                    tree.delete(b);
                }
                else if (a.startsWith(b)) {
                    bTree.set(a.slice(b.length), aTree);
                    tree.delete(a);
                }
            }
        }
        for (const c of tree.values()) {
            this.nestPT(c);
        }
    }
}
exports.TreeBuilder = TreeBuilder;
